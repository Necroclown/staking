import React, { useState, useEffect } from 'react';
import { Wallet, Plus, Clock, Star, Zap, Trophy, Coins, RefreshCw } from 'lucide-react';

const WaxNFTStaking = () => {
  const [wax, setWax] = useState(null);
  const [walletConnected, setWalletConnected] = useState(false);
  const [walletAddress, setWalletAddress] = useState('');
  const [userNFTs, setUserNFTs] = useState([]);
  const [stakingSlots, setStakingSlots] = useState(6);
  const [stakedNFTs, setStakedNFTs] = useState({});
  const [userStats, setUserStats] = useState({
    level: 1,
    experience: 0,
    totalClaimed: 0,
    avatar: 'rookie'
  });
  const [currentTime, setCurrentTime] = useState(Date.now());
  const [loading, setLoading] = useState(false);
  const [waxBalance, setWaxBalance] = useState(0);

  // WAX Configuration
  const WAX_RPC_ENDPOINT = 'https://wax.greymass.com';
  const ATOMICASSETS_API = 'https://wax.api.atomicassets.io';
  const STAKING_CONTRACT = 'stakingcntrct'; // Your deployed contract
  
  const slotPrices = [100, 150, 225, 338, 507, 760]; // WAXP prices for additional slots
  const maxProduction = 72; // hours
  const experienceToLevel = (level) => level * 100;

  useEffect(() => {
    initializeWax();
    const timer = setInterval(() => {
      setCurrentTime(Date.now());
    }, 1000);
    return () => clearInterval(timer);
  }, []);

  const initializeWax = async () => {
    try {
      // Initialize WAX Cloud Wallet
      const { wax } = await import('https://cdn.jsdelivr.net/npm/@waxio/waxjs@1.0.4/dist/waxjs.min.js');
      const waxInstance = new wax.WaxJS({
        rpcEndpoint: WAX_RPC_ENDPOINT,
        tryAutoLogin: true
      });
      
      setWax(waxInstance);
      
      // Try auto-login
      try {
        const userAccount = await waxInstance.login();
        if (userAccount) {
          setWalletConnected(true);
          setWalletAddress(userAccount);
          await loadUserData(userAccount);
        }
      } catch (e) {
        console.log('Auto-login failed');
      }
    } catch (error) {
      console.error('Failed to initialize WAX:', error);
    }
  };

  const connectWallet = async () => {
    if (!wax) {
      alert('WAX wallet not initialized. Please refresh the page.');
      return;
    }

    try {
      setLoading(true);
      const userAccount = await wax.login();
      setWalletConnected(true);
      setWalletAddress(userAccount);
      await loadUserData(userAccount);
    } catch (error) {
      console.error('Failed to connect wallet:', error);
      alert('Failed to connect wallet. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const loadUserData = async (account) => {
    try {
      setLoading(true);
      
      // Load user's NFTs from AtomicAssets
      await loadUserNFTs(account);
      
      // Load WAX balance
      await loadWaxBalance(account);
      
      // Load staked NFTs and user stats from your contract
      await loadStakedData(account);
      
    } catch (error) {
      console.error('Failed to load user data:', error);
    } finally {
      setLoading(false);
    }
  };

  const loadUserNFTs = async (account) => {
    try {
      const response = await fetch(
        `${ATOMICASSETS_API}/atomicassets/v1/assets?owner=${account}&page=1&limit=100&order=desc&sort=asset_id`
      );
      
      if (!response.ok) throw new Error('Failed to fetch NFTs');
      
      const data = await response.json();
      
      // Filter and format NFTs for staking
      const formattedNFTs = data.data.map(nft => ({
        id: nft.asset_id,
        name: nft.name || `${nft.collection.name} #${nft.template.template_id}`,
        image: nft.data.img ? `https://ipfs.io/ipfs/${nft.data.img}` : '🎮',
        collection: nft.collection.name,
        schema: nft.schema.schema_name,
        template_id: nft.template.template_id,
        rarity: nft.data.rarity || 'common',
        // Calculate rate based on rarity or template
        rate: calculateNFTRate(nft)
      }));
      
      setUserNFTs(formattedNFTs);
    } catch (error) {
      console.error('Failed to load NFTs:', error);
      // Fallback to mock data for demo
      setUserNFTs([
        { id: 'demo1', name: 'Demo NFT #1', image: '🚀', rarity: 'rare', rate: 2 },
        { id: 'demo2', name: 'Demo NFT #2', image: '⭐', rarity: 'epic', rate: 3 }
      ]);
    }
  };

  const calculateNFTRate = (nft) => {
    // Implement your rate calculation logic based on NFT properties
    const rarityRates = {
      'common': 1,
      'uncommon': 1.5,
      'rare': 2,
      'epic': 3,
      'legendary': 5
    };
    return rarityRates[nft.data.rarity] || 1;
  };

  const loadWaxBalance = async (account) => {
    try {
      const response = await fetch(WAX_RPC_ENDPOINT + '/v1/chain/get_currency_balance', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          code: 'eosio.token',
          account: account,
          symbol: 'WAX'
        })
      });
      
      const data = await response.json();
      const balance = data.length > 0 ? parseFloat(data[0].split(' ')[0]) : 0;
      setWaxBalance(balance);
    } catch (error) {
      console.error('Failed to load WAX balance:', error);
      setWaxBalance(0);
    }
  };

  const loadStakedData = async (account) => {
    try {
      // Load staked NFTs from your contract
      const response = await fetch(WAX_RPC_ENDPOINT + '/v1/chain/get_table_rows', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          json: true,
          code: STAKING_CONTRACT,
          scope: account,
          table: 'stakes',
          limit: 100
        })
      });
      
      const data = await response.json();
      
      // Process staked NFTs
      const staked = {};
      data.rows.forEach(row => {
        staked[row.slot_id] = {
          nft: {
            id: row.asset_id,
            name: row.nft_name,
            image: row.nft_image,
            rarity: row.rarity,
            rate: row.production_rate
          },
          stakedAt: new Date(row.staked_at).getTime()
        };
      });
      setStakedNFTs(staked);
      
      // Load user stats
      const statsResponse = await fetch(WAX_RPC_ENDPOINT + '/v1/chain/get_table_rows', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          json: true,
          code: STAKING_CONTRACT,
          scope: STAKING_CONTRACT,
          table: 'users',
          lower_bound: account,
          upper_bound: account,
          limit: 1
        })
      });
      
      const statsData = await statsResponse.json();
      if (statsData.rows.length > 0) {
        const userData = statsData.rows[0];
        setUserStats({
          level: userData.level,
          experience: userData.experience,
          totalClaimed: userData.total_claimed,
          avatar: getAvatarByLevel(userData.level)
        });
        setStakingSlots(userData.total_slots);
      }
      
    } catch (error) {
      console.error('Failed to load staked data:', error);
    }
  };

  const stakeNFT = async (slotIndex, nft) => {
    if (!wax || !walletConnected) return;
    
    try {
      setLoading(true);
      
      const actions = [
        {
          account: 'atomicassets',
          name: 'transfer',
          authorization: [{
            actor: walletAddress,
            permission: 'active',
          }],
          data: {
            from: walletAddress,
            to: STAKING_CONTRACT,
            asset_ids: [nft.id],
            memo: `stake:${slotIndex}`
          },
        },
        {
          account: STAKING_CONTRACT,
          name: 'stake',
          authorization: [{
            actor: walletAddress,
            permission: 'active',
          }],
          data: {
            user: walletAddress,
            asset_id: nft.id,
            slot_id: slotIndex
          },
        }
      ];
      
      const result = await wax.api.transact({
        actions: actions
      }, {
        blocksBehind: 3,
        expireSeconds: 1200,
      });
      
      console.log('Staking transaction successful:', result);
      
      // Update local state
      setStakedNFTs(prev => ({
        ...prev,
        [slotIndex]: {
          nft,
          stakedAt: currentTime
        }
      }));
      
      // Remove NFT from available list
      setUserNFTs(prev => prev.filter(n => n.id !== nft.id));
      
    } catch (error) {
      console.error('Failed to stake NFT:', error);
      alert('Failed to stake NFT: ' + error.message);
    } finally {
      setLoading(false);
    }
  };

  const unstakeNFT = async (slotIndex) => {
    if (!wax || !walletConnected) return;
    
    const stakedNFT = stakedNFTs[slotIndex];
    if (!stakedNFT) return;
    
    try {
      setLoading(true);
      
      const result = await wax.api.transact({
        actions: [{
          account: STAKING_CONTRACT,
          name: 'unstake',
          authorization: [{
            actor: walletAddress,
            permission: 'active',
          }],
          data: {
            user: walletAddress,
            slot_id: slotIndex
          },
        }]
      }, {
        blocksBehind: 3,
        expireSeconds: 1200,
      });
      
      console.log('Unstaking transaction successful:', result);
      
      // Update local state
      setStakedNFTs(prev => {
        const newStaked = { ...prev };
        delete newStaked[slotIndex];
        return newStaked;
      });
      
      // Add NFT back to available list
      setUserNFTs(prev => [...prev, stakedNFT.nft]);
      
    } catch (error) {
      console.error('Failed to unstake NFT:', error);
      alert('Failed to unstake NFT: ' + error.message);
    } finally {
      setLoading(false);
    }
  };

  const claimRewards = async (slotIndex) => {
    if (!wax || !walletConnected) return;
    
    const stakedNFT = stakedNFTs[slotIndex];
    if (!stakedNFT) return;
    
    try {
      setLoading(true);
      
      const result = await wax.api.transact({
        actions: [{
          account: STAKING_CONTRACT,
          name: 'claim',
          authorization: [{
            actor: walletAddress,
            permission: 'active',
          }],
          data: {
            user: walletAddress,
            slot_id: slotIndex
          },
        }]
      }, {
        blocksBehind: 3,
        expireSeconds: 1200,
      });
      
      console.log('Claim transaction successful:', result);
      
      const production = calculateProduction(stakedNFT.stakedAt, stakedNFT.nft.rate);
      
      // Update user stats
      setUserStats(prev => {
        const newExp = prev.experience + 1;
        const newLevel = Math.floor(newExp / 100) + 1;
        return {
          ...prev,
          experience: newExp,
          level: newLevel,
          totalClaimed: prev.totalClaimed + production,
          avatar: getAvatarByLevel(newLevel)
        };
      });
      
      // Reset staking time
      setStakedNFTs(prev => ({
        ...prev,
        [slotIndex]: {
          ...prev[slotIndex],
          stakedAt: currentTime
        }
      }));
      
    } catch (error) {
      console.error('Failed to claim rewards:', error);
      alert('Failed to claim rewards: ' + error.message);
    } finally {
      setLoading(false);
    }
  };

  const buySlot = async (slotIndex) => {
    if (!wax || !walletConnected) return;
    
    const price = slotPrices[slotIndex - 6];
    if (!price) return;
    
    if (waxBalance < price) {
      alert(`Insufficient WAX balance. You need ${price} WAX but only have ${waxBalance.toFixed(4)} WAX.`);
      return;
    }
    
    try {
      setLoading(true);
      
      const result = await wax.api.transact({
        actions: [{
          account: 'eosio.token',
          name: 'transfer',
          authorization: [{
            actor: walletAddress,
            permission: 'active',
          }],
          data: {
            from: walletAddress,
            to: STAKING_CONTRACT,
            quantity: `${price.toFixed(8)} WAX`,
            memo: 'buy_slot'
          },
        }, {
          account: STAKING_CONTRACT,
          name: 'buyslot',
          authorization: [{
            actor: walletAddress,
            permission: 'active',
          }],
          data: {
            user: walletAddress
          },
        }]
      }, {
        blocksBehind: 3,
        expireSeconds: 1200,
      });
      
      console.log('Buy slot transaction successful:', result);
      
      setStakingSlots(prev => prev + 1);
      setWaxBalance(prev => prev - price);
      
    } catch (error) {
      console.error('Failed to buy slot:', error);
      alert('Failed to buy slot: ' + error.message);
    } finally {
      setLoading(false);
    }
  };

  const refreshData = async () => {
    if (walletConnected && walletAddress) {
      await loadUserData(walletAddress);
    }
  };

  const calculateProduction = (stakedAt, rate) => {
    const hoursStaked = (currentTime - stakedAt) / (1000 * 60 * 60);
    const production = Math.min(hoursStaked * rate, maxProduction * rate);
    return production;
  };

  const calculateProgress = (stakedAt) => {
    const hoursStaked = (currentTime - stakedAt) / (1000 * 60 * 60);
    return Math.min((hoursStaked / maxProduction) * 100, 100);
  };

  const getAvatarByLevel = (level) => {
    if (level >= 50) return 'legend';
    if (level >= 25) return 'master';
    if (level >= 10) return 'expert';
    if (level >= 5) return 'veteran';
    return 'rookie';
  };

  const getAvatarEmoji = (avatar) => {
    const avatars = {
      rookie: '👤',
      veteran: '🎖️',
      expert: '🏆',
      master: '👑',
      legend: '🌟'
    };
    return avatars[avatar] || '👤';
  };

  const getRarityColor = (rarity) => {
    const colors = {
      common: 'border-gray-400 bg-gray-50',
      uncommon: 'border-green-400 bg-green-50',
      rare: 'border-blue-400 bg-blue-50',
      epic: 'border-purple-400 bg-purple-50',
      legendary: 'border-yellow-400 bg-yellow-50'
    };
    return colors[rarity] || colors.common;
  };

  if (!walletConnected) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 flex items-center justify-center p-4">
        <div className="bg-white/10 backdrop-blur-lg rounded-2xl p-8 text-center max-w-md w-full border border-white/20">
          <div className="text-6xl mb-6">🚀</div>
          <h1 className="text-3xl font-bold text-white mb-4">WAX NFT Staking</h1>
          <p className="text-white/80 mb-8">Connect your WAX Cloud Wallet to stake NFTs and earn cryptocurrency rewards!</p>
          <button
            onClick={connectWallet}
            disabled={loading}
            className="bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white px-8 py-3 rounded-lg font-semibold flex items-center gap-2 mx-auto transition-all duration-200 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {loading ? (
              <RefreshCw size={20} className="animate-spin" />
            ) : (
              <Wallet size={20} />
            )}
            {loading ? 'Connecting...' : 'Connect WAX Wallet'}
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 p-4">
      <div className="max-w-7xl mx-auto">
        {/* Header */}
        <div className="bg-white/10 backdrop-blur-lg rounded-2xl p-6 mb-6 border border-white/20">
          <div className="flex flex-col lg:flex-row justify-between items-start lg:items-center gap-4">
            <div className="flex items-center gap-4">
              <div>
                <h1 className="text-3xl font-bold text-white mb-2">WAX NFT Staking Platform</h1>
                <p className="text-white/70">Connected: {walletAddress}</p>
                <p className="text-white/70">Balance: {waxBalance.toFixed(4)} WAX</p>
              </div>
              <button
                onClick={refreshData}
                disabled={loading}
                className="bg-white/10 hover:bg-white/20 text-white p-2 rounded-lg transition-all duration-200 disabled:opacity-50"
              >
                <RefreshCw size={20} className={loading ? 'animate-spin' : ''} />
              </button>
            </div>
            
            {/* User Stats */}
            <div className="bg-white/10 rounded-xl p-4 flex items-center gap-4">
              <div className="text-4xl">{getAvatarEmoji(userStats.avatar)}</div>
              <div className="text-white">
                <div className="font-semibold">Level {userStats.level}</div>
                <div className="text-sm text-white/70">
                  {userStats.experience % 100}/{experienceToLevel(1)} XP
                </div>
                <div className="w-24 bg-white/20 rounded-full h-2 mt-1">
                  <div 
                    className="bg-gradient-to-r from-purple-400 to-pink-400 h-2 rounded-full transition-all duration-300"
                    style={{ width: `${(userStats.experience % 100)}%` }}
                  />
                </div>
              </div>
              <div className="text-right text-white">
                <div className="text-sm text-white/70">Total Claimed</div>
                <div className="font-bold">{userStats.totalClaimed.toFixed(2)} 💎</div>
              </div>
            </div>
          </div>
        </div>

        {/* Staking Slots */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
          {Array.from({ length: 12 }, (_, i) => i).map(slotIndex => {
            const isUnlocked = slotIndex < stakingSlots;
            const stakedNFT = stakedNFTs[slotIndex];
            const canPurchase = slotIndex >= 6 && slotIndex < stakingSlots + 1;
            
            if (!isUnlocked && !canPurchase) return null;

            return (
              <div key={slotIndex} className="bg-white/10 backdrop-blur-lg rounded-2xl p-6 border border-white/20">
                <div className="text-center mb-4">
                  <h3 className="text-white font-semibold">Slot {slotIndex + 1}</h3>
                </div>

                {!isUnlocked && canPurchase ? (
                  <div className="text-center">
                    <div className="text-4xl mb-4">🔒</div>
                    <p className="text-white/70 mb-4">Unlock this slot</p>
                    <button
                      onClick={() => buySlot(slotIndex)}
                      disabled={loading || waxBalance < slotPrices[slotIndex - 6]}
                      className="bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white px-4 py-2 rounded-lg font-semibold flex items-center gap-2 mx-auto transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      <Coins size={16} />
                      {slotPrices[slotIndex - 6]} WAX
                    </button>
                  </div>
                ) : stakedNFT ? (
                  <div>
                    <div className={`rounded-lg p-4 mb-4 border-2 ${getRarityColor(stakedNFT.nft.rarity)}`}>
                      <div className="text-center">
                        <div className="text-3xl mb-2">
                          {typeof stakedNFT.nft.image === 'string' && stakedNFT.nft.image.startsWith('http') ? (
                            <img src={stakedNFT.nft.image} alt={stakedNFT.nft.name} className="w-12 h-12 mx-auto rounded" />
                          ) : (
                            stakedNFT.nft.image
                          )}
                        </div>
                        <div className="font-semibold text-gray-800 text-sm">{stakedNFT.nft.name}</div>
                        <div className="text-xs text-gray-600 capitalize">{stakedNFT.nft.rarity}</div>
                        <div className="text-xs text-gray-600">{stakedNFT.nft.rate} 💎/hour</div>
                      </div>
                    </div>

                    {/* Production Progress */}
                    <div className="mb-4">
                      <div className="flex justify-between text-white text-sm mb-2">
                        <span>Production</span>
                        <span>{calculateProduction(stakedNFT.stakedAt, stakedNFT.nft.rate).toFixed(2)} 💎</span>
                      </div>
                      <div className="w-full bg-white/20 rounded-full h-3">
                        <div 
                          className="bg-gradient-to-r from-green-400 to-emerald-400 h-3 rounded-full transition-all duration-1000"
                          style={{ width: `${calculateProgress(stakedNFT.stakedAt)}%` }}
                        />
                      </div>
                      <div className="text-xs text-white/70 mt-1 text-center">
                        {((currentTime - stakedNFT.stakedAt) / (1000 * 60 * 60)).toFixed(1)}/72 hours
                      </div>
                    </div>

                    <div className="flex gap-2">
                      <button
                        onClick={() => claimRewards(slotIndex)}
                        disabled={loading || calculateProgress(stakedNFT.stakedAt) < 100}
                        className={`flex-1 px-4 py-2 rounded-lg font-semibold flex items-center justify-center gap-2 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed ${
                          calculateProgress(stakedNFT.stakedAt) >= 100
                            ? 'bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white'
                            : 'bg-gray-600 text-gray-400'
                        }`}
                      >
                        {loading ? <RefreshCw size={16} className="animate-spin" /> : <Trophy size={16} />}
                        Claim
                      </button>
                      <button
                        onClick={() => unstakeNFT(slotIndex)}
                        disabled={loading}
                        className="px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg font-semibold transition-all duration-200 disabled:opacity-50"
                      >
                        Unstake
                      </button>
                    </div>
                  </div>
                ) : (
                  <div className="text-center">
                    <div className="text-4xl mb-4">➕</div>
                    <p className="text-white/70 mb-4">Stake an NFT</p>
                    <select
                      onChange={(e) => {
                        const nftId = e.target.value;
                        if (nftId) {
                          const nft = userNFTs.find(n => n.id === nftId);
                          if (nft) stakeNFT(slotIndex, nft);
                        }
                      }}
                      disabled={loading || userNFTs.length === 0}
                      className="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-white disabled:opacity-50"
                    >
                      <option value="">
                        {userNFTs.length === 0 ? 'No NFTs available' : 'Select NFT...'}
                      </option>
                      {userNFTs.map(nft => (
                        <option key={nft.id} value={nft.id} className="text-black">
                          {nft.name} ({nft.rate} 💎/hr)
                        </option>
                      ))}
                    </select>
                  </div>
                )}
              </div>
            );
          })}
        </div>

        {/* NFT Collection */}
        <div className="bg-white/10 backdrop-blur-lg rounded-2xl p-6 border border-white/20">
          <div className="flex justify-between items-center mb-6">
            <h2 className="text-2xl font-bold text-white">Your NFT Collection</h2>
            <button
              onClick={refreshData}
              disabled={loading}
              className="bg-white/10 hover:bg-white/20 text-white px-4 py-2 rounded-lg font-semibold flex items-center gap-2 transition-all duration-200 disabled:opacity-50"
            >
              <RefreshCw size={16} className={loading ? 'animate-spin' : ''} />
              Refresh
            </button>
          </div>
          
          {userNFTs.length === 0 ? (
            <div className="text-center text-white/70 py-8">
              {loading ? 'Loading your NFTs...' : 'No unstaked NFTs found. Make sure you have NFTs in your WAX wallet.'}
            </div>
          ) : (
            <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
              {userNFTs.map(nft => (
                <div key={nft.id} className={`rounded-lg p-4 border-2 ${getRarityColor(nft.rarity)}`}>
                  <div className="text-center">
                    <div className="text-2xl mb-2">
                      {typeof nft.image === 'string' && nft.image.startsWith('http') ? (
                        <img src={nft.image} alt={nft.name} className="w-8 h-8 mx-auto rounded" />
                      ) : (
                        nft.image
                      )}
                    </div>
                    <div className="font-semibold text-gray-800 text-xs">{nft.name}</div>
                    <div className="text-xs text-gray-600 capitalize">{nft.rarity}</div>
                    <div className="text-xs text-gray-600">{nft.rate} 💎/hour</div>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default WaxNFTStaking;
